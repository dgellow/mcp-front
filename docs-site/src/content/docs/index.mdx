---
title: MCP Front
description: Authentication proxy for MCP servers
---

import CustomHero from '../../components/CustomHero.astro';

<CustomHero
  title="MCP Front"
  tagline="OAuth 2.1 proxy for Model Context Protocol"
  actions={[
    {
      text: 'Quickstart',
      link: '/mcp-front/quickstart/',
      icon: 'right-arrow',
      variant: 'primary',
    },
    {
      text: 'GitHub',
      link: 'https://github.com/dgellow/mcp-front',
      icon: 'github',
      attrs: { target: '_blank' },
    },
  ]}
/>

MCP Front is an authentication proxy that sits between Claude and your MCP servers. It handles user authentication so your MCP servers don't have to.

## The problem with MCP authentication

MCP servers only support static bearer tokens stored in configuration files. This works fine for personal use, but creates problems when you want to share MCP servers with your team. You can't tell who's using what. You can't revoke access when someone leaves. And your database credentials are sitting in plaintext.

MCP Front fixes this by adding a proper authentication layer between Claude and your servers. Your MCP servers stay exactly the same. MCP Front validates the user, then proxies authenticated requests to your servers. You get user attribution, access control, and audit logs without changing a line of MCP server code.

## Authentication

Users log in with their company Google account, and MCP Front checks they're from your domain. You get individual user tracking and instant access revocation.

```json
{
  "auth": {
    "kind": "oauth",
    "issuer": "https://mcp.company.com",
    "allowedDomains": ["company.com"],
    "googleClientId": { "$env": "GOOGLE_CLIENT_ID" },
    "googleClientSecret": { "$env": "GOOGLE_CLIENT_SECRET" },
    "jwtSecret": { "$env": "JWT_SECRET" },
    "encryptionKey": { "$env": "ENCRYPTION_KEY" }
  }
}
```

<details>
<summary>Or use bearer tokens</summary>

For development or simple setups, you can use static bearer tokens. Map server names to lists of valid tokens. Users provide a token when connecting, and if it's in the list for that server, they get access.

```json
{
  "auth": {
    "kind": "bearerToken",
    "tokens": {
      "linear": [{ "$env": "MY_ACCESS_TOKEN" }]
    }
  }
}
```

</details>

## Try it in 30 seconds

```bash
# Create a minimal config
cat > config.json << 'EOF'
{
  "version": "v0.0.1-DEV_EDITION_EXPECT_CHANGES",
  "proxy": {
    "name": "Test Proxy",
    "addr": ":8080",
    "auth": {
      "kind": "bearerToken",
      "tokens": {
        "filesystem": ["test-123"]
      }
    }
  },
  "mcpServers": {
    "filesystem": {
      "transportType": "stdio",
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-filesystem", "/tmp"]
    }
  }
}
EOF

# Run it
docker run -p 8080:8080 -v ./config.json:/config.json ghcr.io/dgellow/mcp-front:latest
```

Then connect from Claude with URL `http://localhost:8080/sse` and token `test-123`. That's it.

## Built for production

MCP Front uses <span class="feature-underline">OAuth 2.1 with PKCE</span>, the latest standard. It integrates with Google Workspace for enterprise SSO. Domain restrictions mean only your employees get access.

Sessions persist in Firestore so they survive restarts. <span class="feature-underline">Structured JSON logging</span> makes debugging straightforward. Health checks work with any monitoring system.

The code is simple Go with minimal dependencies.
